{"version":3,"file":"index.js","sources":["../src/utils/math.ts","../src/kmeans.ts","../src/utils/image.ts","../src/utils/color-space.ts","../src/utils/lab.ts"],"sourcesContent":["import { RGBA } from './struct'\n/**\n * 返回两个四维坐标间的欧几里得距离\n * @param a \n * @param b \n * @returns \n */\nexport function euclidean_distance(a: RGBA, b: RGBA) {\n    const r = a[0] - b[0]\n    const g = a[1] - b[1]\n    const _b = a[2] - b[2]\n    const _a = a[3] - b[3]\n    return Math.sqrt(\n        r ** 2\n        + g ** 2\n        + _b ** 2\n        + _a ** 2\n    )\n    /* return Math.sqrt(\n        Math.pow(a[0] - b[0], 2)\n        + Math.pow(a[1] - b[1], 2)\n        + Math.pow(a[2] - b[2], 2)\n        + Math.pow(a[3] - b[3], 2)\n    ) */\n}\n/**\n * 以数组形式返回三个数字中的最大值与最小值\n * @param param0 一个包含三个数字的数组\n * @returns [max,min]\n */\nexport function max_min_of_three([a, b, c]: [number, number, number]) {\n    if (a > b) {\n        if (b > c) {\n            //abc\n            return [a, c]\n        } else {\n            if (a > c) {\n                //acb\n                return [a, b]\n            } else {\n                //cab\n                return [c, b]\n            }\n        }\n    } else {\n        //a<b\n        if (b > c) {\n            if (c > a) {\n                //bca\n                return [b, a]\n            } else {\n                //bac\n                return [b, c]\n            }\n        } else {\n            //cba\n            return [c, a]\n        }\n    }\n}","import { euclidean_distance } from \"./utils/math\"\nimport { Vector4 } from \"./utils/struct\"\n\nexport default function kmeans(data: Vector4[], k: number, attempt: number, thresold = 1): KMeansResult {\n    const cluster_centers: Vector4[] = []\n    const new_cluster_centers: Vector4[] = []\n    const cluster_sum: [number, number, number, number, number][]/*[r,g,b,a,c]*/ = []\n    let iteration = 0\n    //随机选点\n    for (let i = 0; i < k; i++) {\n        cluster_centers.push(data[Math.floor(Math.random() * data.length)])\n        cluster_sum.push(_filled_array(0, 5) as [number, number, number, number, number])\n    }\n    while (iteration < attempt) {\n        //准备坐标和\n        //计算每个点与中心的距离\n        for (let i = 0; i < data.length; i++) {\n            const data_item = data[i]\n            let cluster_index = 0\n            let _min_distance = euclidean_distance(data_item, cluster_centers[0])\n            for (let j = 1; j < k; j++) {\n                const distance = euclidean_distance(data_item, cluster_centers[j])\n                if (distance < _min_distance) {\n                    _min_distance = distance\n                    cluster_index = j\n                }\n            }\n            const sum = cluster_sum[cluster_index]\n            sum[0] += data_item[0]\n            sum[1] += data_item[1]\n            sum[2] += data_item[2]\n            sum[3] += data_item[3]\n            sum[4]++\n        }\n        let diff = 0\n        //重新计算中心点\n        for (let i = 0; i < k; i++) {\n            const rgbac = cluster_sum[i]\n            const count = rgbac[4]\n            if (count == 0) {\n                //空类 重新选中心点\n                new_cluster_centers[i] = data[Math.floor(Math.random() * data.length)]\n            } else {\n                new_cluster_centers[i] = [rgbac[0] / count, rgbac[1] / count, rgbac[2] / count, rgbac[3] / count]\n            }\n            diff += euclidean_distance(cluster_centers[i], new_cluster_centers[i])\n        }\n        if (diff <= thresold) {\n            return {\n                centroid: new_cluster_centers, iteration, fit: true, label: cluster_sum.map(v => v[4]), size: data.length\n            }\n        }\n        _swap_array(new_cluster_centers, cluster_centers)\n        iteration++\n        //清空累加\n        for (let i = 0; i < k; i++) {\n            const sum_array = cluster_sum[i]\n            sum_array[0] = 0\n            sum_array[1] = 0\n            sum_array[2] = 0\n            sum_array[3] = 0\n            sum_array[4] = 0\n        }\n    }\n    return {\n        centroid: cluster_centers, iteration, fit: false, label: cluster_sum.map(v => v[4]), size: data.length\n    }\n}\nexport interface KMeansResult {\n    centroid: Vector4[],\n    iteration: number,\n    /**是否符合阈值要求 */\n    fit: boolean,\n    label: number[]\n    /**输入的图像的像素计数 */\n    size: number\n}\nfunction _swap_array(from: Array<any>, to: Array<any>) {\n    for (let i = 0; i < from.length; i++) {\n        to[i] = from[i]\n    }\n}\nfunction _filled_array<T>(fillWith: T, count: number) {\n    const array: T[] = []\n    for (let i = 0; i < count; i++) {\n        array.push(fillWith)\n    }\n    return array\n}","import { CanvasRenderingContext2D, NodeCanvasRenderingContext2D } from \"canvas\"\nimport { RGBA } from \"./struct\"\n\nfunction _prepare2DContext(width: number, height: number) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d') as NodeCanvasRenderingContext2D | CanvasRenderingContext2D\n    canvas.height = height\n    canvas.width = width\n    return ctx\n}\n/**\n * Use OffscreenCanvas\n */\nfunction _prepare2DContextAsync(width: number, height: number) {\n    const canvas = new OffscreenCanvas(width, height)\n    const ctx = canvas.getContext('2d')!\n    return ctx\n}\nexport function awaitImage(imgElement: HTMLImageElement) {\n    return new Promise<Event>((resolve, reject) => {\n        imgElement.addEventListener('load', (e: Event) => {\n            resolve(e)\n        })\n        imgElement.addEventListener('error', (reason) => {\n            reject(reason)\n        })\n    })\n}\nexport function readImage(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContext, imgSource)\n}\nexport function readImageAsync(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContextAsync as any, imgSource)\n}\nfunction _readImage(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement) {\n    const { naturalWidth, naturalHeight } = imgSource;\n    const ctx = prepareCtx(naturalWidth, naturalHeight)\n    ctx?.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n    return ctx?.getImageData(0, 0, naturalWidth, naturalHeight);\n}\n/**\n * 降采样后读取图片\n * @param imgSource \n * @param maxSample \n * @returns \n */\nexport function readImageDownsampling(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContext, imgSource, maxSample)\n}\nexport function readImageDownsamplingAsync(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContextAsync as any, imgSource, maxSample)\n}\nfunction _readImageDownsampling(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement, maxSample: number) {\n    const { naturalWidth: width, naturalHeight: height } = imgSource\n    const scale = width * height / maxSample\n    if (scale > 1) {\n        const n_width = width / Math.sqrt(scale)\n        const n_height = height / Math.sqrt(scale)\n        const ctx = prepareCtx(n_width, n_height)\n        ctx?.drawImage(imgSource, 0, 0, n_width, n_height)\n        return ctx?.getImageData(0, 0, n_width, n_height)\n    } else {\n        const ctx = prepareCtx(width, height)\n        ctx?.drawImage(imgSource, 0, 0)\n        return ctx?.getImageData(0, 0, width, height)\n    }\n}\n/**\n * 从@type {Uint8ClampedArray} 中读取，每四个元素合并到一个数组元素中\n * @param img 要处理的图像矩阵\n * @returns \n */\nexport function toPixel(img: ImageData) {\n    const { data } = img\n    const array: RGBA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        array.push(data.slice(i, i + 4))\n    }\n    return array\n}\n","import { RGBA, HSLA } from \"./struct\"\nimport { max_min_of_three } from './math'\n\nexport function normalizeRGBA(rgba: RGBA): RGBA {\n    //@ts-ignore\n    return rgba.map(v => v / 255)\n}\nexport function rgbaToHSLA(rgba: RGBA): HSLA {\n    let h, s\n    //@ts-ignore\n    const [max, min] = max_min_of_three(rgba)\n    const diff = max - min\n    const light_2x = max + min\n    //h\n    if (diff == 0) {\n        h = 0\n        s = 0\n    } else {\n        if (max == rgba[0]) {\n            const temp_h = 60 * (rgba[1] - rgba[2]) / diff\n            if (temp_h < 0) {\n                h = temp_h + 360\n            } else {\n                h = temp_h\n            }\n        } else if (max == rgba[1]) {\n            h = 60 * (rgba[2] - rgba[0]) / diff + 120\n        } else {\n            h = 60 * (rgba[0] - rgba[1]) / diff + 240\n        }\n        if (light_2x == 0) {\n            s = 0\n        } else if (light_2x <= 1) {\n            s = diff / light_2x\n        } else {\n            s = diff / (2 - light_2x)\n        }\n    }\n    return [h, s, light_2x / 2, rgba[3]]\n}\nfunction adjustAngleIn2Pi(angle: number) {\n    if (angle < 0) return angle + 360\n    let temp = angle\n    while (temp >= 360) {\n        temp = angle - 360\n    }\n    return temp\n}\nexport type IndexOFHSLA = 0 | 1 | 2 | 3\nexport const sortHSL = (sort: IndexOFHSLA[] = [0, 1, 2, 3]) =>\n    (a: HSLA, b: HSLA) => {\n        let result: number\n        for (const s of sort) {\n            result = a[s] - b[s]\n            if (result != 0) {\n                return result\n            }\n        }\n        //其实是赋了值的，但是ts没猜出来\n        //@ts-ignore\n        return result\n    }\nexport const hslaCSSText = ([h, s, l, a]: HSLA) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`\nexport const rgbaCSSText = (pixel: RGBA) => `rgba(${pixel.map(v => Math.floor(v)).join(',')})`\n","import rgb from 'color-space/rgb'\nimport xyz from 'color-space/xyz'\nimport lab from 'color-space/lab'\nimport { LABA, RGBA } from './struct'\n\nexport function toPixelLAB(img: ImageData) {\n    const { data } = img\n    const array: LABA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        const pixel = data.slice(i, i + 4)\n        const alpha = pixel[3]\n        const pixel_rgb = pixel.slice(0, 3)\n        const pixel_xyz = rgb.xyz(pixel_rgb)\n        const pixel_lab = xyz.lab(pixel_xyz) as [number, number, number]\n        array.push([...pixel_lab, alpha])\n    }\n    return array\n}\nexport function labaToRGBA(laba: LABA): RGBA {\n    const pixel_lab = laba.slice(0, 3)\n    const alpha = laba[3]\n    const pixel_xyz = lab.xyz(pixel_lab)\n    const pixel_rgb = xyz.rgb(pixel_xyz) as [number, number, number]\n    return [...pixel_rgb, alpha]\n}"],"names":["euclidean_distance","a","b","g","_b","_a","Math","sqrt","_swap_array","from","to","i","length","_filled_array","fillWith","count","array","push","_prepare2DContext","width","height","canvas","document","createElement","ctx","getContext","_prepare2DContextAsync","OffscreenCanvas","_readImage","prepareCtx","imgSource","naturalWidth","naturalHeight","drawImage","getImageData","_readImageDownsampling","maxSample","scale","n_width","n_height","imgElement","Promise","resolve","reject","addEventListener","e","reason","data","k","attempt","thresold","cluster_centers","new_cluster_centers","cluster_sum","iteration","floor","random","data_item","cluster_index","_min_distance","j","distance","sum","diff","rgbac","centroid","fit","label","map","v","size","sum_array","laba","pixel_lab","slice","alpha","pixel_xyz","lab","xyz","pixel_rgb","rgb","rgba","pixel","join","h","s","c","max","min","light_2x","temp_h","sort","result","img"],"mappings":"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"}