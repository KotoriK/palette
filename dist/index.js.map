{"version":3,"file":"index.js","sources":["../src/util.ts","../src/kmeans.ts"],"sourcesContent":["import { CanvasRenderingContext2D, NodeCanvasRenderingContext2D } from \"canvas\"\n\nexport type HSLA = [number, number, number, number]\nexport type RGBA = [number, number, number, number] | Uint8ClampedArray\nexport function awaitImage(imgElement: HTMLImageElement) {\n    return new Promise<Event>((resolve, reject) => {\n        imgElement.addEventListener('load', (e: Event) => {\n            resolve(e)\n        })\n        imgElement.addEventListener('error', (reason) => {\n            reject(reason)\n        })\n    })\n}\nexport function readImage(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContext, imgSource)\n}\nexport function readImageAsync(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContextAsync as any, imgSource)\n}\nfunction _readImage(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement) {\n    const { naturalWidth, naturalHeight } = imgSource;\n    const ctx = prepareCtx(naturalWidth, naturalHeight)\n    ctx?.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n    return ctx?.getImageData(0, 0, naturalWidth, naturalHeight);\n}\n/**\n * 降采样后读取图片\n * @param imgSource \n * @param maxSample \n * @returns \n */\nexport function readImageDownsampling(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContext, imgSource, maxSample)\n}\nexport function readImageDownsamplingAsync(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContextAsync as any, imgSource, maxSample)\n}\nfunction _readImageDownsampling(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement, maxSample: number) {\n    const { naturalWidth: width, naturalHeight: height } = imgSource\n    const scale = width * height / maxSample\n    if (scale > 1) {\n        const n_width = width / Math.sqrt(scale)\n        const n_height = height / Math.sqrt(scale)\n        const ctx = prepareCtx(n_width, n_height)\n        ctx?.drawImage(imgSource, 0, 0, n_width, n_height)\n        return ctx?.getImageData(0, 0, n_width, n_height)\n    } else {\n        const ctx = prepareCtx(width, height)\n        ctx?.drawImage(imgSource, 0, 0)\n        return ctx?.getImageData(0, 0, width, height)\n    }\n}\nfunction _prepare2DContext(width: number, height: number) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d') as NodeCanvasRenderingContext2D | CanvasRenderingContext2D\n    canvas.height = height\n    canvas.width = width\n    return ctx\n}\n/**\n * Use OffscreenCanvas\n */\nfunction _prepare2DContextAsync(width: number, height: number) {\n    const canvas = new OffscreenCanvas(width, height)\n    const ctx = canvas.getContext('2d')!\n    return ctx\n}\n/**\n * 从@type {Uint8ClampedArray} 中读取，每四个元素合并到一个数组元素中\n * @param img 要处理的图像矩阵\n * @returns \n */\nexport function toPixel(img: ImageData) {\n    const { data } = img\n    const array: RGBA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        array.push(data.slice(i, i + 4))\n    }\n    return array\n}\n/**\n * 返回两个四维坐标间的欧几里得距离\n * @param a \n * @param b \n * @returns \n */\nexport function euclidean_distance(a: RGBA, b: RGBA) {\n    const r = a[0] - b[0]\n    const g = a[1] - b[1]\n    const _b = a[2] - b[2]\n    const _a = a[3] - b[3]\n    return Math.sqrt(\n        r * r\n        + g * g\n        + _b * _b\n        + _a * _a\n    )\n    /* return Math.sqrt(\n        Math.pow(a[0] - b[0], 2)\n        + Math.pow(a[1] - b[1], 2)\n        + Math.pow(a[2] - b[2], 2)\n        + Math.pow(a[3] - b[3], 2)\n    ) */\n}\n/**\n * 以数组形式返回三个数字中的最大值与最小值\n * @param param0 一个包含三个数字的数组\n * @returns [max,min]\n */\nfunction max_min_of_three([a, b, c]: [number, number, number]) {\n    if (a > b) {\n        if (b > c) {\n            //abc\n            return [a, c]\n        } else {\n            if (a > c) {\n                //acb\n                return [a, b]\n            } else {\n                //cab\n                return [c, b]\n            }\n        }\n    } else {\n        //a<b\n        if (b > c) {\n            if (c > a) {\n                //bca\n                return [b, a]\n            } else {\n                //bac\n                return [b, c]\n            }\n        } else {\n            //cba\n            return [c, a]\n        }\n    }\n}\nexport function normalizeRGBA(rgba: RGBA): RGBA {\n    //@ts-ignore\n    return rgba.map(v => v / 255)\n}\nexport function rgbaToHSLA(rgba: RGBA): HSLA {\n    let h, s\n    //@ts-ignore\n    const [max, min] = max_min_of_three(rgba)\n    const diff = max - min\n    const light_2x = max + min\n    //h\n    if (diff == 0) {\n        h = 0\n        s = 0\n    } else {\n        if (max == rgba[0]) {\n            const temp_h = 60 * (rgba[1] - rgba[2]) / diff\n            if (temp_h < 0) {\n                h = temp_h + 360\n            } else {\n                h = temp_h\n            }\n        } else if (max == rgba[1]) {\n            h = 60 * (rgba[2] - rgba[0]) / diff + 120\n        } else {\n            h = 60 * (rgba[0] - rgba[1]) / diff + 240\n        }\n        if (light_2x == 0) {\n            s = 0\n        } else if (light_2x <= 1) {\n            s = diff / light_2x\n        } else {\n            s = diff / (2 - light_2x)\n        }\n    }\n    return [h, s, light_2x / 2, rgba[3]]\n}\nfunction adjustAngleIn2Pi(angle: number) {\n    if (angle < 0) return angle + 360\n    let temp = angle\n    while (temp >= 360) {\n        temp = angle - 360\n    }\n    return temp\n}\nexport type IndexOFHSLA = 0 | 1 | 2 | 3\nexport const sortHSL = (sort: IndexOFHSLA[] = [0, 1, 2, 3]) =>\n    (a: HSLA, b: HSLA) => {\n        let result: number\n        for (const s of sort) {\n            result = a[s] - b[s]\n            if (result != 0) {\n                return result\n            }\n        }\n        //其实是赋了值的，但是ts没猜出来\n        //@ts-ignore\n        return result\n    }\nexport const hslaCSSText = ([h, s, l, a]: HSLA) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`\nexport const rgbaCSSText = (pixel: RGBA) => `rgba(${pixel.map(v => Math.floor(v)).join(',')})`\n/* export class RGBAArray extends Uint8ClampedArray {\n    pixel(pixel_index: number) {\n        return [pixel_index * 4, pixel_index * 4 + 1, pixel_index * 4 + 2, pixel_index * 4 + 3]\n    }\n    r(pixel_index: number) {\n        return pixel_index * 4\n    }\n    g(pixel_index: number) {\n        return pixel_index * 4 + 1\n    }\n    b(pixel_index: number) {\n        return pixel_index * 4 + 2\n    }\n    a(pixel_index: number) {\n        return pixel_index * 4 + 3\n    }\n} */","import { RGBA, euclidean_distance } from \"./util\"\nconst THRESOLD = 1\n\nexport default function kmeans(data: RGBA[], k: number, attempt: number): KMeansResult {\n    const cluster_centers: RGBA[] = []\n    const new_cluster_centers: RGBA[] = []\n    const cluster_sum: [number, number, number, number, number][]/*[r,g,b,a,c]*/ = []\n    let iterate_time = 0\n\n    for (let i = 0; i < k; i++) {\n        cluster_centers.push(data[Math.floor(Math.random() * data.length)])    //随机选点\n        cluster_sum.push(_filled_array(0, 5) as [number, number, number, number, number])\n    }\n    while (iterate_time < attempt) {\n        //准备坐标和\n        //计算每个点与中心的距离\n        for (let i = 0; i < data.length; i++) {\n            const data_item = data[i]\n            let cluster_index = 0\n            let _min_distance = euclidean_distance(data_item, cluster_centers[0])\n            for (let j = 1; j < k; j++) {\n                const distance = euclidean_distance(data_item, cluster_centers[j])\n                if (distance < _min_distance) {\n                    _min_distance = distance\n                    cluster_index = j\n                }\n            }\n            const sum = cluster_sum[cluster_index]\n            sum[0] += data_item[0]\n            sum[1] += data_item[1]\n            sum[2] += data_item[2]\n            sum[3] += data_item[3]\n            sum[4]++\n        }\n        let diff = 0\n        //重新计算中心点\n        for (let i = 0; i < k; i++) {\n            const rgbac = cluster_sum[i]\n            const count = rgbac[4]\n            if (count == 0) {\n                new_cluster_centers[i] = data[Math.floor(Math.random() * data.length)]\n            } else {\n                new_cluster_centers[i] = [rgbac[0] / count, rgbac[1] / count, rgbac[2] / count, rgbac[3] / count]\n            }\n            diff += euclidean_distance(cluster_centers[i], new_cluster_centers[i])\n        }\n        if (diff <= THRESOLD) {\n            return {\n                cluster_center: new_cluster_centers, iterate_time, fit_thresold: true, label: cluster_sum.map(v => v[4]), size: data.length\n            }\n        }\n        _swap_array(new_cluster_centers, cluster_centers)\n        iterate_time++\n        //清空累加\n        for (let i = 0; i < k; i++) {\n            const sum_array = cluster_sum[i]\n            sum_array[0] = 0\n            sum_array[1] = 0\n            sum_array[2] = 0\n            sum_array[3] = 0\n            sum_array[4] = 0\n        }\n    }\n    return {\n        cluster_center: cluster_centers, iterate_time, fit_thresold: false, label: cluster_sum.map(v => v[4]), size: data.length\n    }\n}\nexport interface KMeansResult {\n    cluster_center: RGBA[],\n    iterate_time: number,\n    fit_thresold: boolean,\n    label: number[]\n    /**输入的图像的像素计数 */\n    size: number\n}\nfunction _swap_array(from: Array<any>, to: Array<any>) {\n    for (let i = 0; i < from.length; i++) {\n        to[i] = from[i]\n    }\n}\nfunction _filled_array<T>(fillWith: T, count: number) {\n    const array: T[] = []\n    for (let i = 0; i < count; i++) {\n        array.push(fillWith)\n    }\n    return array\n}"],"names":["_readImage","prepareCtx","imgSource","naturalWidth","naturalHeight","ctx","drawImage","getImageData","_readImageDownsampling","maxSample","width","height","scale","n_width","Math","sqrt","n_height","_prepare2DContext","canvas","document","createElement","getContext","_prepare2DContextAsync","OffscreenCanvas","euclidean_distance","a","b","r","g","_b","_a","_swap_array","from","to","i","length","_filled_array","fillWith","count","array","push","imgElement","Promise","resolve","reject","addEventListener","e","reason","data","k","attempt","cluster_centers","new_cluster_centers","cluster_sum","iterate_time","floor","random","data_item","cluster_index","_min_distance","j","distance","sum","diff","rgbac","cluster_center","fit_thresold","label","map","v","size","sum_array","rgba","pixel","join","h","s","c","max","min","light_2x","temp_h","sort","result","img","slice"],"mappings":"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"}