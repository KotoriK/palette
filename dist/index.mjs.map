{"version":3,"file":"index.mjs","sources":["../src/utils/math.ts","../src/kmeans.ts","../src/utils/image.ts","../src/utils/color-space.ts","../src/utils/lab.ts"],"sourcesContent":["import { RGBA } from './struct'\n/**\n * 返回两个四维坐标间的欧几里得距离\n * @param a \n * @param b \n * @returns \n */\nexport function euclidean_distance(a: RGBA, b: RGBA) {\n    const r = a[0] - b[0]\n    const g = a[1] - b[1]\n    const _b = a[2] - b[2]\n    const _a = a[3] - b[3]\n    return Math.sqrt(\n        r ** 2\n        + g ** 2\n        + _b ** 2\n        + _a ** 2\n    )\n    /* return Math.sqrt(\n        Math.pow(a[0] - b[0], 2)\n        + Math.pow(a[1] - b[1], 2)\n        + Math.pow(a[2] - b[2], 2)\n        + Math.pow(a[3] - b[3], 2)\n    ) */\n}\n/**\n * 以数组形式返回三个数字中的最大值与最小值\n * @param param0 一个包含三个数字的数组\n * @returns [max,min]\n */\nexport function max_min_of_three([a, b, c]: [number, number, number]) {\n    if (a > b) {\n        if (b > c) {\n            //abc\n            return [a, c]\n        } else {\n            if (a > c) {\n                //acb\n                return [a, b]\n            } else {\n                //cab\n                return [c, b]\n            }\n        }\n    } else {\n        //a<b\n        if (b > c) {\n            if (c > a) {\n                //bca\n                return [b, a]\n            } else {\n                //bac\n                return [b, c]\n            }\n        } else {\n            //cba\n            return [c, a]\n        }\n    }\n}","import { euclidean_distance } from \"./utils/math\"\nimport { Vector4 } from \"./utils/struct\"\n\nexport default function kmeans(data: Vector4[], k: number, attempt: number, thresold = 1): KMeansResult {\n    const cluster_centers: Vector4[] = []\n    const new_cluster_centers: Vector4[] = []\n    const cluster_sum: [number, number, number, number, number][]/*[r,g,b,a,c]*/ = []\n    let iteration = 0\n    //随机选点\n    for (let i = 0; i < k; i++) {\n        cluster_centers.push(data[Math.floor(Math.random() * data.length)])\n        cluster_sum.push(_filled_array(0, 5) as [number, number, number, number, number])\n    }\n    while (iteration < attempt) {\n        //准备坐标和\n        //计算每个点与中心的距离\n        for (let i = 0; i < data.length; i++) {\n            const data_item = data[i]\n            let cluster_index = 0\n            let _min_distance = euclidean_distance(data_item, cluster_centers[0])\n            for (let j = 1; j < k; j++) {\n                const distance = euclidean_distance(data_item, cluster_centers[j])\n                if (distance < _min_distance) {\n                    _min_distance = distance\n                    cluster_index = j\n                }\n            }\n            const sum = cluster_sum[cluster_index]\n            sum[0] += data_item[0]\n            sum[1] += data_item[1]\n            sum[2] += data_item[2]\n            sum[3] += data_item[3]\n            sum[4]++\n        }\n        let diff = 0\n        //重新计算中心点\n        for (let i = 0; i < k; i++) {\n            const rgbac = cluster_sum[i]\n            const count = rgbac[4]\n            if (count == 0) {\n                //空类 重新选中心点\n                new_cluster_centers[i] = data[Math.floor(Math.random() * data.length)]\n            } else {\n                new_cluster_centers[i] = [rgbac[0] / count, rgbac[1] / count, rgbac[2] / count, rgbac[3] / count]\n            }\n            diff += euclidean_distance(cluster_centers[i], new_cluster_centers[i])\n        }\n        if (diff <= thresold) {\n            return {\n                centroid: new_cluster_centers, iteration, fit: true, label: cluster_sum.map(v => v[4]), size: data.length\n            }\n        }\n        _swap_array(new_cluster_centers, cluster_centers)\n        iteration++\n        //清空累加\n        for (let i = 0; i < k; i++) {\n            const sum_array = cluster_sum[i]\n            sum_array[0] = 0\n            sum_array[1] = 0\n            sum_array[2] = 0\n            sum_array[3] = 0\n            sum_array[4] = 0\n        }\n    }\n    return {\n        centroid: cluster_centers, iteration, fit: false, label: cluster_sum.map(v => v[4]), size: data.length\n    }\n}\nexport interface KMeansResult {\n    centroid: Vector4[],\n    iteration: number,\n    /**是否符合阈值要求 */\n    fit: boolean,\n    label: number[]\n    /**输入的图像的像素计数 */\n    size: number\n}\nfunction _swap_array(from: Array<any>, to: Array<any>) {\n    for (let i = 0; i < from.length; i++) {\n        to[i] = from[i]\n    }\n}\nfunction _filled_array<T>(fillWith: T, count: number) {\n    const array: T[] = []\n    for (let i = 0; i < count; i++) {\n        array.push(fillWith)\n    }\n    return array\n}","import { CanvasRenderingContext2D, NodeCanvasRenderingContext2D } from \"canvas\"\nimport { RGBA } from \"./struct\"\n\nfunction _prepare2DContext(width: number, height: number) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d') as NodeCanvasRenderingContext2D | CanvasRenderingContext2D\n    canvas.height = height\n    canvas.width = width\n    return ctx\n}\n/**\n * Use OffscreenCanvas\n */\nfunction _prepare2DContextAsync(width: number, height: number) {\n    const canvas = new OffscreenCanvas(width, height)\n    const ctx = canvas.getContext('2d')!\n    return ctx\n}\nexport function awaitImage(imgElement: HTMLImageElement) {\n    return new Promise<Event>((resolve, reject) => {\n        imgElement.addEventListener('load', (e: Event) => {\n            resolve(e)\n        })\n        imgElement.addEventListener('error', (reason) => {\n            reject(reason)\n        })\n    })\n}\nexport function readImage(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContext, imgSource)\n}\nexport function readImageAsync(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContextAsync as any, imgSource)\n}\nfunction _readImage(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement) {\n    const { naturalWidth, naturalHeight } = imgSource;\n    const ctx = prepareCtx(naturalWidth, naturalHeight)\n    ctx?.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n    return ctx?.getImageData(0, 0, naturalWidth, naturalHeight);\n}\n/**\n * 降采样后读取图片\n * @param imgSource \n * @param maxSample \n * @returns \n */\nexport function readImageDownsampling(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContext, imgSource, maxSample)\n}\nexport function readImageDownsamplingAsync(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContextAsync as any, imgSource, maxSample)\n}\nfunction _readImageDownsampling(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement, maxSample: number) {\n    const { naturalWidth: width, naturalHeight: height } = imgSource\n    const scale = width * height / maxSample\n    if (scale > 1) {\n        const n_width = width / Math.sqrt(scale)\n        const n_height = height / Math.sqrt(scale)\n        const ctx = prepareCtx(n_width, n_height)\n        ctx?.drawImage(imgSource, 0, 0, n_width, n_height)\n        return ctx?.getImageData(0, 0, n_width, n_height)\n    } else {\n        const ctx = prepareCtx(width, height)\n        ctx?.drawImage(imgSource, 0, 0)\n        return ctx?.getImageData(0, 0, width, height)\n    }\n}\n/**\n * 从@type {Uint8ClampedArray} 中读取，每四个元素合并到一个数组元素中\n * @param img 要处理的图像矩阵\n * @returns \n */\nexport function toPixel(img: ImageData) {\n    const { data } = img\n    const array: RGBA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        array.push(data.slice(i, i + 4))\n    }\n    return array\n}\n","import { RGBA, HSLA } from \"./struct\"\nimport { max_min_of_three } from './math'\n\nexport function normalizeRGBA(rgba: RGBA): RGBA {\n    //@ts-ignore\n    return rgba.map(v => v / 255)\n}\nexport function rgbaToHSLA(rgba: RGBA): HSLA {\n    let h, s\n    //@ts-ignore\n    const [max, min] = max_min_of_three(rgba)\n    const diff = max - min\n    const light_2x = max + min\n    //h\n    if (diff == 0) {\n        h = 0\n        s = 0\n    } else {\n        if (max == rgba[0]) {\n            const temp_h = 60 * (rgba[1] - rgba[2]) / diff\n            if (temp_h < 0) {\n                h = temp_h + 360\n            } else {\n                h = temp_h\n            }\n        } else if (max == rgba[1]) {\n            h = 60 * (rgba[2] - rgba[0]) / diff + 120\n        } else {\n            h = 60 * (rgba[0] - rgba[1]) / diff + 240\n        }\n        if (light_2x == 0) {\n            s = 0\n        } else if (light_2x <= 1) {\n            s = diff / light_2x\n        } else {\n            s = diff / (2 - light_2x)\n        }\n    }\n    return [h, s, light_2x / 2, rgba[3]]\n}\nfunction adjustAngleIn2Pi(angle: number) {\n    if (angle < 0) return angle + 360\n    let temp = angle\n    while (temp >= 360) {\n        temp = angle - 360\n    }\n    return temp\n}\nexport type IndexOFHSLA = 0 | 1 | 2 | 3\nexport const sortHSL = (sort: IndexOFHSLA[] = [0, 1, 2, 3]) =>\n    (a: HSLA, b: HSLA) => {\n        let result: number\n        for (const s of sort) {\n            result = a[s] - b[s]\n            if (result != 0) {\n                return result\n            }\n        }\n        //其实是赋了值的，但是ts没猜出来\n        //@ts-ignore\n        return result\n    }\nexport const hslaCSSText = ([h, s, l, a]: HSLA) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`\nexport const rgbaCSSText = (pixel: RGBA) => `rgba(${pixel.map(v => Math.floor(v)).join(',')})`\n","import rgb from 'color-space/rgb'\nimport xyz from 'color-space/xyz'\nimport lab from 'color-space/lab'\nimport { LABA, RGBA } from './struct'\n\nexport function toPixelLAB(img: ImageData) {\n    const { data } = img\n    const array: LABA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        const pixel = data.slice(i, i + 4)\n        const alpha = pixel[3]\n        const pixel_rgb = pixel.slice(0, 3)\n        const pixel_xyz = rgb.xyz(pixel_rgb)\n        const pixel_lab = xyz.lab(pixel_xyz) as [number, number, number]\n        array.push([...pixel_lab, alpha])\n    }\n    return array\n}\nexport function labaToRGBA(laba: LABA): RGBA {\n    const pixel_lab = laba.slice(0, 3)\n    const alpha = laba[3]\n    const pixel_xyz = lab.xyz(pixel_lab)\n    const pixel_rgb = xyz.rgb(pixel_xyz) as [number, number, number]\n    return [...pixel_rgb, alpha]\n}"],"names":["euclidean_distance","a","b","g","_b","_a","Math","sqrt","kmeans","data","k","attempt","thresold","cluster_centers","new_cluster_centers","cluster_sum","iteration","i","push","floor","random","length","_filled_array","data_item","cluster_index","_min_distance","j","distance","sum","diff","rgbac","count","centroid","fit","label","map","v","size","_swap_array","sum_array","from","to","fillWith","array","_prepare2DContext","width","height","canvas","document","createElement","ctx","getContext","_prepare2DContextAsync","OffscreenCanvas","awaitImage","imgElement","Promise","resolve","reject","addEventListener","e","reason","readImage","imgSource","_readImage","readImageAsync","prepareCtx","naturalWidth","naturalHeight","drawImage","getImageData","readImageDownsampling","maxSample","_readImageDownsampling","readImageDownsamplingAsync","scale","n_width","n_height","toPixel","img","slice","normalizeRGBA","rgba","rgbaToHSLA","h","s","c","max","min","light_2x","temp_h","sortHSL","sort","result","hslaCSSText","rgbaCSSText","pixel","join","toPixelLAB","alpha","pixel_rgb","pixel_xyz","rgb","xyz","pixel_lab","lab","labaToRGBA","laba"],"mappings":"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"}