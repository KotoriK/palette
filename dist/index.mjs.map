{"version":3,"file":"index.mjs","sources":["../src/util.ts","../src/kmeans.ts"],"sourcesContent":["import { CanvasRenderingContext2D, NodeCanvasRenderingContext2D } from \"canvas\"\n\nexport type HSLA = [number, number, number, number]\nexport type RGBA = [number, number, number, number] | Uint8ClampedArray\nexport function awaitImage(imgElement: HTMLImageElement) {\n    return new Promise<Event>((resolve, reject) => {\n        imgElement.addEventListener('load', (e: Event) => {\n            resolve(e)\n        })\n        imgElement.addEventListener('error', (reason) => {\n            reject(reason)\n        })\n    })\n}\nexport function readImage(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContext, imgSource)\n}\nexport function readImageAsync(imgSource: HTMLImageElement) {\n    return _readImage(_prepare2DContextAsync as any, imgSource)\n}\nfunction _readImage(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement) {\n    const { naturalWidth, naturalHeight } = imgSource;\n    const ctx = prepareCtx(naturalWidth, naturalHeight)\n    ctx?.drawImage(imgSource, 0, 0, naturalWidth, naturalHeight);\n    return ctx?.getImageData(0, 0, naturalWidth, naturalHeight);\n}\n/**\n * 降采样后读取图片\n * @param imgSource \n * @param maxSample \n * @returns \n */\nexport function readImageDownsampling(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContext, imgSource, maxSample)\n}\nexport function readImageDownsamplingAsync(imgSource: HTMLImageElement, maxSample: number) {\n    return _readImageDownsampling(_prepare2DContextAsync as any, imgSource, maxSample)\n}\nfunction _readImageDownsampling(prepareCtx: (width: number, height: number) => CanvasRenderingContext2D, imgSource: HTMLImageElement, maxSample: number) {\n    const { naturalWidth: width, naturalHeight: height } = imgSource\n    const scale = width * height / maxSample\n    if (scale > 1) {\n        const n_width = width / Math.sqrt(scale)\n        const n_height = height / Math.sqrt(scale)\n        const ctx = prepareCtx(n_width, n_height)\n        ctx?.drawImage(imgSource, 0, 0, n_width, n_height)\n        return ctx?.getImageData(0, 0, n_width, n_height)\n    } else {\n        const ctx = prepareCtx(width, height)\n        ctx?.drawImage(imgSource, 0, 0)\n        return ctx?.getImageData(0, 0, width, height)\n    }\n}\nfunction _prepare2DContext(width: number, height: number) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d') as NodeCanvasRenderingContext2D | CanvasRenderingContext2D\n    canvas.height = height\n    canvas.width = width\n    return ctx\n}\n/**\n * Use OffscreenCanvas\n */\nfunction _prepare2DContextAsync(width: number, height: number) {\n    const canvas = new OffscreenCanvas(width, height)\n    const ctx = canvas.getContext('2d')!\n    return ctx\n}\n/**\n * 从@type {Uint8ClampedArray} 中读取，每四个元素合并到一个数组元素中\n * @param img 要处理的图像矩阵\n * @returns \n */\nexport function toPixel(img: ImageData) {\n    const { data } = img\n    const array: RGBA[] = []\n    for (let i = 0; i < data.length; i += 4) {\n        array.push(data.slice(i, i + 4))\n    }\n    return array\n}\n/**\n * 返回两个四维坐标间的欧几里得距离\n * @param a \n * @param b \n * @returns \n */\nexport function euclidean_distance(a: RGBA, b: RGBA) {\n    const r = a[0] - b[0]\n    const g = a[1] - b[1]\n    const _b = a[2] - b[2]\n    const _a = a[3] - b[3]\n    return Math.sqrt(\n        r * r\n        + g * g\n        + _b * _b\n        + _a * _a\n    )\n    /* return Math.sqrt(\n        Math.pow(a[0] - b[0], 2)\n        + Math.pow(a[1] - b[1], 2)\n        + Math.pow(a[2] - b[2], 2)\n        + Math.pow(a[3] - b[3], 2)\n    ) */\n}\n/**\n * 以数组形式返回三个数字中的最大值与最小值\n * @param param0 一个包含三个数字的数组\n * @returns [max,min]\n */\nfunction max_min_of_three([a, b, c]: [number, number, number]) {\n    if (a > b) {\n        if (b > c) {\n            //abc\n            return [a, c]\n        } else {\n            if (a > c) {\n                //acb\n                return [a, b]\n            } else {\n                //cab\n                return [c, b]\n            }\n        }\n    } else {\n        //a<b\n        if (b > c) {\n            if (c > a) {\n                //bca\n                return [b, a]\n            } else {\n                //bac\n                return [b, c]\n            }\n        } else {\n            //cba\n            return [c, a]\n        }\n    }\n}\nexport function normalizeRGBA(rgba: RGBA): RGBA {\n    //@ts-ignore\n    return rgba.map(v => v / 255)\n}\nexport function rgbaToHSLA(rgba: RGBA): HSLA {\n    let h, s\n    //@ts-ignore\n    const [max, min] = max_min_of_three(rgba)\n    const diff = max - min\n    const light_2x = max + min\n    //h\n    if (diff == 0) {\n        h = 0\n        s = 0\n    } else {\n        if (max == rgba[0]) {\n            const temp_h = 60 * (rgba[1] - rgba[2]) / diff\n            if (temp_h < 0) {\n                h = temp_h + 360\n            } else {\n                h = temp_h\n            }\n        } else if (max == rgba[1]) {\n            h = 60 * (rgba[2] - rgba[0]) / diff + 120\n        } else {\n            h = 60 * (rgba[0] - rgba[1]) / diff + 240\n        }\n        if (light_2x == 0) {\n            s = 0\n        } else if (light_2x <= 1) {\n            s = diff / light_2x\n        } else {\n            s = diff / (2 - light_2x)\n        }\n    }\n    return [h, s, light_2x / 2, rgba[3]]\n}\nfunction adjustAngleIn2Pi(angle: number) {\n    if (angle < 0) return angle + 360\n    let temp = angle\n    while (temp >= 360) {\n        temp = angle - 360\n    }\n    return temp\n}\nexport type IndexOFHSLA = 0 | 1 | 2 | 3\nexport const sortHSL = (sort: IndexOFHSLA[] = [0, 1, 2, 3]) =>\n    (a: HSLA, b: HSLA) => {\n        let result: number\n        for (const s of sort) {\n            result = a[s] - b[s]\n            if (result != 0) {\n                return result\n            }\n        }\n        //其实是赋了值的，但是ts没猜出来\n        //@ts-ignore\n        return result\n    }\nexport const hslaCSSText = ([h, s, l, a]: HSLA) => `hsla(${h}deg,${s * 100}%,${l * 100}%,${a})`\nexport const rgbaCSSText = (pixel: RGBA) => `rgba(${pixel.map(v => Math.floor(v)).join(',')})`\n/* export class RGBAArray extends Uint8ClampedArray {\n    pixel(pixel_index: number) {\n        return [pixel_index * 4, pixel_index * 4 + 1, pixel_index * 4 + 2, pixel_index * 4 + 3]\n    }\n    r(pixel_index: number) {\n        return pixel_index * 4\n    }\n    g(pixel_index: number) {\n        return pixel_index * 4 + 1\n    }\n    b(pixel_index: number) {\n        return pixel_index * 4 + 2\n    }\n    a(pixel_index: number) {\n        return pixel_index * 4 + 3\n    }\n} */","import { RGBA, euclidean_distance } from \"./util\"\nconst THRESOLD = 1\n\nexport default function kmeans(data: RGBA[], k: number, attempt: number): KMeansResult {\n    const cluster_centers: RGBA[] = []\n    const new_cluster_centers: RGBA[] = []\n    const cluster_sum: [number, number, number, number, number][]/*[r,g,b,a,c]*/ = []\n    let iterate_time = 0\n\n    for (let i = 0; i < k; i++) {\n        cluster_centers.push(data[Math.floor(Math.random() * data.length)])    //随机选点\n        cluster_sum.push(_filled_array(0, 5) as [number, number, number, number, number])\n    }\n    while (iterate_time < attempt) {\n        //准备坐标和\n        //计算每个点与中心的距离\n        for (let i = 0; i < data.length; i++) {\n            const data_item = data[i]\n            let cluster_index = 0\n            let _min_distance = euclidean_distance(data_item, cluster_centers[0])\n            for (let j = 1; j < k; j++) {\n                const distance = euclidean_distance(data_item, cluster_centers[j])\n                if (distance < _min_distance) {\n                    _min_distance = distance\n                    cluster_index = j\n                }\n            }\n            const sum = cluster_sum[cluster_index]\n            sum[0] += data_item[0]\n            sum[1] += data_item[1]\n            sum[2] += data_item[2]\n            sum[3] += data_item[3]\n            sum[4]++\n        }\n        let diff = 0\n        //重新计算中心点\n        for (let i = 0; i < k; i++) {\n            const rgbac = cluster_sum[i]\n            const count = rgbac[4]\n            if (count == 0) {\n                new_cluster_centers[i] = data[Math.floor(Math.random() * data.length)]\n            } else {\n                new_cluster_centers[i] = [rgbac[0] / count, rgbac[1] / count, rgbac[2] / count, rgbac[3] / count]\n            }\n            diff += euclidean_distance(cluster_centers[i], new_cluster_centers[i])\n        }\n        if (diff <= THRESOLD) {\n            return {\n                cluster_center: new_cluster_centers, iterate_time, fit_thresold: true, label: cluster_sum.map(v => v[4]), size: data.length\n            }\n        }\n        _swap_array(new_cluster_centers, cluster_centers)\n        iterate_time++\n        //清空累加\n        for (let i = 0; i < k; i++) {\n            const sum_array = cluster_sum[i]\n            sum_array[0] = 0\n            sum_array[1] = 0\n            sum_array[2] = 0\n            sum_array[3] = 0\n            sum_array[4] = 0\n        }\n    }\n    return {\n        cluster_center: cluster_centers, iterate_time, fit_thresold: false, label: cluster_sum.map(v => v[4]), size: data.length\n    }\n}\nexport interface KMeansResult {\n    cluster_center: RGBA[],\n    iterate_time: number,\n    fit_thresold: boolean,\n    label: number[]\n    /**输入的图像的像素计数 */\n    size: number\n}\nfunction _swap_array(from: Array<any>, to: Array<any>) {\n    for (let i = 0; i < from.length; i++) {\n        to[i] = from[i]\n    }\n}\nfunction _filled_array<T>(fillWith: T, count: number) {\n    const array: T[] = []\n    for (let i = 0; i < count; i++) {\n        array.push(fillWith)\n    }\n    return array\n}"],"names":["awaitImage","imgElement","Promise","resolve","reject","addEventListener","e","reason","readImage","imgSource","_readImage","_prepare2DContext","readImageAsync","_prepare2DContextAsync","prepareCtx","naturalWidth","naturalHeight","ctx","drawImage","getImageData","readImageDownsampling","maxSample","_readImageDownsampling","readImageDownsamplingAsync","width","height","scale","n_width","Math","sqrt","n_height","canvas","document","createElement","getContext","OffscreenCanvas","toPixel","img","data","array","i","length","push","slice","euclidean_distance","a","b","r","g","_b","_a","normalizeRGBA","rgba","map","v","rgbaToHSLA","h","s","c","max","min","diff","light_2x","temp_h","sortHSL","sort","result","hslaCSSText","rgbaCSSText","pixel","floor","join","kmeans","k","attempt","cluster_centers","new_cluster_centers","cluster_sum","iterate_time","random","_filled_array","data_item","cluster_index","_min_distance","j","distance","sum","rgbac","count","cluster_center","fit_thresold","label","size","_swap_array","sum_array","from","to","fillWith"],"mappings":"mHAIgBA,EAAWC,GACvB,WAAWC,QAAe,SAACC,EAASC,GAChCH,EAAWI,iBAAiB,OAAQ,SAACC,GACjCH,EAAQG,KAEZL,EAAWI,iBAAiB,QAAS,SAACE,GAClCH,EAAOG,gBAIHC,EAAUC,GACtB,OAAOC,EAAWC,EAAmBF,YAEzBG,EAAeH,GAC3B,OAAOC,EAAWG,EAA+BJ,GAErD,SAASC,EAAWI,EAAyEL,GACzF,IAAQM,EAAgCN,EAAhCM,aAAcC,EAAkBP,EAAlBO,cAChBC,EAAMH,EAAWC,EAAcC,GAErC,aADAC,GAAAA,EAAKC,UAAUT,EAAW,EAAG,EAAGM,EAAcC,SACvCC,SAAAA,EAAKE,aAAa,EAAG,EAAGJ,EAAcC,YAQjCI,EAAsBX,EAA6BY,GAC/D,OAAOC,EAAuBX,EAAmBF,EAAWY,YAEhDE,EAA2Bd,EAA6BY,GACpE,OAAOC,EAAuBT,EAA+BJ,EAAWY,GAE5E,SAASC,EAAuBR,EAAyEL,EAA6BY,GAClI,IAAsBG,EAAiCf,EAA/CM,aAAoCU,EAAWhB,EAA1BO,cACvBU,EAAQF,EAAQC,EAASJ,EAC/B,GAAIK,EAAQ,EAAG,CACX,IAAMC,EAAUH,EAAQI,KAAKC,KAAKH,GAC5BI,EAAWL,EAASG,KAAKC,KAAKH,GAC9BT,EAAMH,EAAWa,EAASG,GAEhC,aADAb,GAAAA,EAAKC,UAAUT,EAAW,EAAG,EAAGkB,EAASG,SAClCb,SAAAA,EAAKE,aAAa,EAAG,EAAGQ,EAASG,GAExC,IAAMb,EAAMH,EAAWU,EAAOC,GAE9B,aADAR,GAAAA,EAAKC,UAAUT,EAAW,EAAG,SACtBQ,SAAAA,EAAKE,aAAa,EAAG,EAAGK,EAAOC,GAG9C,SAASd,EAAkBa,EAAeC,GACtC,IAAMM,EAASC,SAASC,cAAc,UAChChB,EAAMc,EAAOG,WAAW,MAG9B,OAFAH,EAAON,OAASA,EAChBM,EAAOP,MAAQA,EACRP,EAKX,SAASJ,EAAuBW,EAAeC,GAG3C,OAFe,IAAIU,gBAAgBX,EAAOC,GACvBS,WAAW,eAQlBE,EAAQC,GAGpB,IAFA,IAAQC,EAASD,EAATC,KACFC,EAAgB,GACbC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,GAAK,EAClCD,EAAMG,KAAKJ,EAAKK,MAAMH,EAAGA,EAAI,IAEjC,OAAOD,WAQKK,EAAmBC,EAASC,GACxC,IAAMC,EAAIF,EAAE,GAAKC,EAAE,GACbE,EAAIH,EAAE,GAAKC,EAAE,GACbG,EAAKJ,EAAE,GAAKC,EAAE,GACdI,EAAKL,EAAE,GAAKC,EAAE,GACpB,OAAOlB,KAAKC,KACRkB,EAAIA,EACFC,EAAIA,EACJC,EAAKA,EACLC,EAAKA,YA4CCC,EAAcC,GAE1B,OAAOA,EAAKC,IAAI,SAAAC,UAAKA,EAAI,eAEbC,EAAWH,GACvB,IAAII,EAAGC,IAnCgBZ,EAAGC,EAAGY,KAAAA,KAqCON,OArCbP,SAAGC,QAElBA,EAAIY,EAEG,CAACb,EAAGa,GAEPb,EAAIa,EAEG,CAACb,EAAGC,GAGJ,CAACY,EAAGZ,GAKfA,EAAIY,EACAA,EAAIb,EAEG,CAACC,EAAGD,GAGJ,CAACC,EAAGY,GAIR,CAACA,EAAGb,IAWZc,OAAKC,OACNC,EAAOF,EAAMC,EACbE,EAAWH,EAAMC,EAEvB,GAAY,GAARC,EACAL,EAAI,EACJC,EAAI,MACD,CACH,GAAIE,GAAOP,EAAK,GAAI,CAChB,IAAMW,EAAS,IAAMX,EAAK,GAAKA,EAAK,IAAMS,EAEtCL,EADAO,EAAS,EACLA,EAAS,IAETA,OAGRP,EADOG,GAAOP,EAAK,GACf,IAAMA,EAAK,GAAKA,EAAK,IAAMS,EAAO,IAElC,IAAMT,EAAK,GAAKA,EAAK,IAAMS,EAAO,IAGtCJ,EADY,GAAZK,EACI,EACGA,GAAY,EACfD,EAAOC,EAEPD,GAAQ,EAAIC,GAGxB,MAAO,CAACN,EAAGC,EAAGK,EAAW,EAAGV,EAAK,IAWxBY,IAAAA,EAAU,SAACC,mBAAAA,IAAAA,EAAsB,CAAC,EAAG,EAAG,EAAG,aACnDpB,EAASC,GAEN,IADA,IAAIoB,grBACYD,kBAAM,KAAXR,UAEP,GAAc,IADdS,EAASrB,EAAEY,GAAKX,EAAEW,IAEd,OAAOS,EAKf,OAAOA,IAEFC,EAAc,sCAA4C,cAAY,wBACtEC,EAAc,SAACC,iBAAwBA,EAAMhB,IAAI,SAAAC,UAAK1B,KAAK0C,MAAMhB,KAAIiB,KAAK,mBCrM/DC,EAAOlC,EAAcmC,EAAWC,GAMpD,IALA,IAAMC,EAA0B,GAC1BC,EAA8B,GAC9BC,EAAyE,GAC3EC,EAAe,EAEVtC,EAAI,EAAGA,EAAIiC,EAAGjC,IACnBmC,EAAgBjC,KAAKJ,EAAKV,KAAK0C,MAAM1C,KAAKmD,SAAWzC,EAAKG,UAC1DoC,EAAYnC,KAAKsC,EAAc,EAAG,IAEtC,KAAOF,EAAeJ,GAAS,CAG3B,IAAK,IAAIlC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAAK,CAIlC,IAHA,IAAMyC,EAAY3C,EAAKE,GACnB0C,EAAgB,EAChBC,EAAgBvC,EAAmBqC,EAAWN,EAAgB,IACzDS,EAAI,EAAGA,EAAIX,EAAGW,IAAK,CACxB,IAAMC,EAAWzC,EAAmBqC,EAAWN,EAAgBS,IAC3DC,EAAWF,IACXA,EAAgBE,EAChBH,EAAgBE,GAGxB,IAAME,EAAMT,EAAYK,GACxBI,EAAI,IAAML,EAAU,GACpBK,EAAI,IAAML,EAAU,GACpBK,EAAI,IAAML,EAAU,GACpBK,EAAI,IAAML,EAAU,GACpBK,EAAI,KAIR,IAFA,IAAIzB,EAAO,EAEFrB,EAAI,EAAGA,EAAIiC,EAAGjC,IAAK,CACxB,IAAM+C,EAAQV,EAAYrC,GACpBgD,EAAQD,EAAM,GAEhBX,EAAoBpC,GADX,GAATgD,EACyBlD,EAAKV,KAAK0C,MAAM1C,KAAKmD,SAAWzC,EAAKG,SAErC,CAAC8C,EAAM,GAAKC,EAAOD,EAAM,GAAKC,EAAOD,EAAM,GAAKC,EAAOD,EAAM,GAAKC,GAE/F3B,GAAQjB,EAAmB+B,EAAgBnC,GAAIoC,EAAoBpC,IAEvE,GAAIqB,GA7CK,EA8CL,MAAO,CACH4B,eAAgBb,EAAqBE,aAAAA,EAAcY,cAAc,EAAMC,MAAOd,EAAYxB,IAAI,SAAAC,UAAKA,EAAE,KAAKsC,KAAMtD,EAAKG,QAG7HoD,EAAYjB,EAAqBD,GACjCG,IAEA,IAAK,IAAItC,EAAI,EAAGA,EAAIiC,EAAGjC,IAAK,CACxB,IAAMsD,EAAYjB,EAAYrC,GAC9BsD,EAAU,GAAK,EACfA,EAAU,GAAK,EACfA,EAAU,GAAK,EACfA,EAAU,GAAK,EACfA,EAAU,GAAK,GAGvB,MAAO,CACHL,eAAgBd,EAAiBG,aAAAA,EAAcY,cAAc,EAAOC,MAAOd,EAAYxB,IAAI,SAAAC,UAAKA,EAAE,KAAKsC,KAAMtD,EAAKG,QAW1H,SAASoD,EAAYE,EAAkBC,GACnC,IAAK,IAAIxD,EAAI,EAAGA,EAAIuD,EAAKtD,OAAQD,IAC7BwD,EAAGxD,GAAKuD,EAAKvD,GAGrB,SAASwC,EAAiBiB,EAAaT,GAEnC,IADA,IAAMjD,EAAa,GACVC,EAAI,EAAGA,EAAIgD,EAAOhD,IACvBD,EAAMG,KAAKuD,GAEf,OAAO1D"}